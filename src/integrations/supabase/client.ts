// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import * as Sentry from '@sentry/react';
import type { Database } from './types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL || "http://localhost:54321";
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZS1kZW1vIiwicm9sZSI6ImFub24iLCJleHAiOjE5ODM4MTI5OTZ9.CRXP1A7WOeoJeXxjNni43kdQwgnWNReilDMblYTn_I0";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

const supabaseClient = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
  }
});

// Helper function to wrap query operations with Sentry spans
function wrapQuery(operation: string, tableOrFn: string, method: () => Promise<any>): Promise<any> {
  try {
    return Sentry.startSpan({ op: 'db.query', name: `${operation} ${tableOrFn}` }, async (span) => {
      span.setTag('db.system', 'supabase');
      span.setTag('db.operation', operation);
      if (operation === 'rpc') {
        span.setTag('db.function', tableOrFn);
      } else {
        span.setTag('db.table', tableOrFn);
      }
      try {
        const result = await method();
        return result;
      } catch (error) {
        Sentry.captureException(error);
        throw error;
      }
    });
  } catch (error) {
    // Sentry not initialized, execute without monitoring
    return method();
  }
}

// Instrument the Supabase client with Sentry monitoring
const instrumentedSupabase = new Proxy(supabaseClient, {
  get(target, prop) {
    if (prop === 'from') {
      return (table: string) => {
        const queryBuilder = target.from(table);
        return new Proxy(queryBuilder, {
          get(qb, method) {
            if (['select', 'insert', 'update', 'delete'].includes(method as string)) {
              return (...args: any[]) => wrapQuery(method as string, table, () => (qb as any)[method](...args));
            }
            return (qb as any)[method];
          }
        });
      };
    } else if (prop === 'rpc') {
      return (fn: string, ...args: any[]) => wrapQuery('rpc', fn, () => target.rpc(fn, ...args));
    } else if (prop === 'auth') {
      const auth = target.auth;
      return new Proxy(auth, {
        get(a, method) {
          if (['signIn', 'signUp', 'signOut', 'resetPassword', 'updateUser'].includes(method as string)) {
            return (...args: any[]) => {
              try {
                Sentry.addBreadcrumb({
                  message: `Auth ${String(method)}`,
                  category: 'auth',
                  level: 'info',
                });
              } catch (error) {
                // Sentry not initialized, skip breadcrumb
              }
              return (a as any)[method](...args);
            };
          }
          return (a as any)[method];
        }
      });
    }
    return (target as any)[prop];
  }
});

export const supabase = instrumentedSupabase;